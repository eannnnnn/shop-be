const fs = require('fs');
const path = require('path');

// Helper function to load TypeScript files
function loadTypeScriptFile(filePath) {
  try {
    // Register ts-node if not already registered
    if (!process[Symbol.for('ts-node.register.instance')]) {
      require('ts-node').register({
        transpileOnly: true,
        compilerOptions: {
          module: 'CommonJS',
          target: 'ES2020',
          moduleResolution: 'node',
          allowSyntheticDefaultImports: true,
          esModuleInterop: true,
          skipLibCheck: true
        }
      });
    }
    
    // Clear require cache
    delete require.cache[require.resolve(filePath)];
    
    const loaded = require(filePath);
    return loaded.default || loaded;
  } catch (error) {
    throw new Error(`Failed to load TypeScript file ${filePath}: ${error.message}`);
  }
}

class SdkConfigurator {
  constructor(configPath, globalDefaults) {
    this.configPath = configPath;
    this.globalDefaults = globalDefaults || this.loadGlobalDefaults();
    this.config = this.loadConfig();
  }

  loadGlobalDefaults() {
    try {
      const globalConfigPath = path.join(__dirname, '../../../sdk.config.cjs');
      if (fs.existsSync(globalConfigPath)) {
        const globalConfig = require(globalConfigPath);
        return globalConfig.defaults || {};
      }
    } catch (error) {
      // Ignore global config errors
    }
    
    // Default fallbacks
    return {
      author: 'Shop Backend Team',
      repository: 'https://github.com/ean-im/shop-be',
      license: 'MIT'
    };
  }

  loadConfig() {
    if (!this.configPath) {
      return null;
    }

    try {
      // Support .ts, .js, .cjs and .json files
      if (this.configPath.endsWith('.ts')) {
        return loadTypeScriptFile(this.configPath);
      } else if (this.configPath.endsWith('.js') || this.configPath.endsWith('.cjs')) {
        // Clear require cache for hot reloading
        delete require.cache[require.resolve(this.configPath)];
        const loaded = require(this.configPath);
        return loaded.default || loaded;
      } else {
        return JSON.parse(fs.readFileSync(this.configPath, 'utf8'));
      }
    } catch (error) {
      // Try alternative file extensions
      const basePath = this.configPath.replace(/\.(ts|js|cjs|json)$/, '');
      
      // Try .ts first (preferred)
      try {
        const tsPath = basePath + '.ts';
        if (fs.existsSync(tsPath)) {
          return loadTypeScriptFile(tsPath);
        }
      } catch (tsError) {
        // Try .cjs (compatible with ESM projects)
        try {
          const cjsPath = basePath + '.cjs';
          if (fs.existsSync(cjsPath)) {
            delete require.cache[require.resolve(cjsPath)];
            const loaded = require(cjsPath);
            return loaded.default || loaded;
          }
        } catch (cjsError) {
          // Try .js
          try {
            const jsPath = basePath + '.js';
            if (fs.existsSync(jsPath)) {
              delete require.cache[require.resolve(jsPath)];
              const loaded = require(jsPath);
              return loaded.default || loaded;
            }
          } catch (jsError) {
            // Fallback to JSON
            try {
              const jsonPath = basePath + '.json';
              if (fs.existsSync(jsonPath)) {
                return JSON.parse(fs.readFileSync(jsonPath, 'utf8'));
              }
            } catch (jsonError) {
              console.error(`Failed to load config from ${this.configPath}:`, error.message);
              return null;
            }
          }
        }
      }
      
      console.error(`Failed to load config from ${this.configPath}:`, error.message);
      return null;
    }
  }

  configureSdk(options = {}) {
    // If no config path provided, try to auto-detect
    if (!this.configPath) {
      const serviceSdkConfig = this.findServiceSdkConfig(options.servicePath);
      if (serviceSdkConfig) {
        this.configPath = serviceSdkConfig;
        this.config = this.loadConfig();
      }
    }

    const packageJsonPath = options.packagePath || path.join(process.cwd(), 'package.json');
    
    try {
      // Read current package.json
      const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      
      // Auto-generate values from service package.json if config is minimal
      let sdkName, sdkDescription, sdkSource;
      
      if (this.config) {
        sdkName = this.config.name;
        sdkDescription = this.config.description;
        sdkSource = this.config.source;
      }
      
      // If no config or missing essential fields, auto-generate from service
      if (!sdkName || !sdkDescription || !sdkSource) {
        const autoGenerated = this.autoGenerateFromService(options.servicePath);
        sdkName = sdkName || autoGenerated.name;
        sdkDescription = sdkDescription || autoGenerated.description;
        sdkSource = sdkSource || autoGenerated.source;
      }
      
      // Update with configured/generated values
      pkg.name = sdkName;
      pkg.description = sdkDescription;
      
      // Set version
      if (this.config?.version) {
        pkg.version = this.config.version;
      }
      
      // Add keywords
      if (this.config?.keywords) {
        pkg.keywords = this.config.keywords;
      }
      
      // Apply package-specific or global defaults
      pkg.author = this.config?.author || this.globalDefaults.author;
      pkg.license = this.config?.license || this.globalDefaults.license;
      
      const repoUrl = this.config?.repository || this.globalDefaults.repository;
      if (repoUrl) {
        pkg.repository = {
          type: 'git',
          url: repoUrl
        };
        pkg.bugs = {
          url: `${repoUrl}/issues`
        };
        pkg.homepage = repoUrl;
      }
      
      // Apply custom fields
      if (this.config?.custom) {
        Object.assign(pkg, this.config.custom);
      }
      
      // Write updated package.json
      fs.writeFileSync(packageJsonPath, JSON.stringify(pkg, null, 2) + '\n');
      
      return {
        success: true,
        packageName: sdkName,
        packagePath: packageJsonPath
      };
    } catch (error) {
      throw new Error(`Failed to update package.json: ${error.message}`);
    }
  }

  findServiceSdkConfig(servicePath) {
    const searchPaths = [
      servicePath && path.resolve(servicePath, 'sdk.config.ts'),
      servicePath && path.resolve(servicePath, 'sdk.config.cjs'),
      servicePath && path.resolve(servicePath, 'sdk.config.js'),
      path.join(process.cwd(), 'sdk.config.ts'),
      path.join(process.cwd(), 'sdk.config.cjs'),
      path.join(process.cwd(), 'sdk.config.js'),
      path.join(process.cwd(), '../../sdk.config.ts'), // from packages/xxx-sdk
      path.join(process.cwd(), '../../sdk.config.cjs'),
      path.join(process.cwd(), '../../sdk.config.js'),
    ].filter(Boolean);

    for (const configPath of searchPaths) {
      if (fs.existsSync(configPath)) {
        return configPath;
      }
    }
    
    return null;
  }

  loadNestiaConfig(servicePath) {
    if (!servicePath) return null;
    
    const nestiaConfigPath = path.resolve(servicePath, 'nestia.config.ts');
    if (!fs.existsSync(nestiaConfigPath)) {
      return null;
    }
    
    try {
      const nestiaConfig = loadTypeScriptFile(nestiaConfigPath);
      return nestiaConfig;
    } catch (error) {
      console.warn(`Failed to load nestia.config.ts: ${error.message}`);
      return null;
    }
  }

  autoDetectFromNestia(servicePath) {
    const nestiaConfig = this.loadNestiaConfig(servicePath);
    if (!nestiaConfig || !nestiaConfig.distribute) {
      return null;
    }
    
    // Convert relative distribute path to absolute SDK package path
    const distributePath = path.resolve(servicePath, nestiaConfig.distribute);
    return distributePath;
  }

  autoGenerateFromService(servicePath) {
    if (!servicePath) {
      throw new Error('Service path is required for auto-generation');
    }
    
    try {
      // Read service package.json
      const servicePackageJsonPath = path.resolve(servicePath, 'package.json');
      const servicePkg = JSON.parse(fs.readFileSync(servicePackageJsonPath, 'utf8'));
      
      // Generate SDK package name by replacing 'service' with 'sdk' or adding '-sdk'
      let sdkName = servicePkg.name;
      if (sdkName.includes('-service')) {
        sdkName = sdkName.replace('-service', '-sdk');
      } else if (sdkName.includes('service')) {
        sdkName = sdkName.replace('service', 'sdk');
      } else {
        sdkName = sdkName + '-sdk';
      }
      
      // Generate description
      const serviceName = path.basename(servicePath);
      const sdkDescription = `${serviceName.charAt(0).toUpperCase() + serviceName.slice(1)} service SDK library generated by Nestia`;
      
      // Generate source path (relative to repo root)
      const repoRoot = path.resolve(servicePath, '../..');
      const relativePath = path.relative(repoRoot, servicePath);
      
      return {
        name: sdkName,
        description: sdkDescription,
        source: relativePath
      };
    } catch (error) {
      throw new Error(`Failed to auto-generate from service package.json: ${error.message}`);
    }
  }

  listSdks() {
    // For individual service configs, return single config
    if (this.config && this.config.name) {
      return [{
        key: path.basename(this.config.source || 'unknown'),
        name: this.config.name,
        description: this.config.description
      }];
    }
    
    // For global configs with packages object
    if (!this.config?.packages) {
      return [];
    }
    return Object.entries(this.config.packages).map(([key, value]) => ({
      key,
      name: value.name,
      description: value.description
    }));
  }
}

module.exports = { SdkConfigurator };